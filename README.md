# botcore

A flexible and efficient bot engine framework for building event-driven bots in Rust.

## Features

- üöÄ **High Performance**: Built on top of Tokio for maximum concurrency and throughput
- üîß **Modular Design**: Easily compose collectors, strategies, and executors
- üìä **Built-in Metrics**: Prometheus metrics for monitoring bot performance
- üõ†Ô∏è **Type-safe**: Leverage Rust's type system for robust bot implementations
- üîÑ **Event-driven**: React to events in real-time with customizable strategies

## Installation

Add `botcore` to your `Cargo.toml`:

```toml
[dependencies]
botcore = "0.1.0"
```

## Quick Start

Here's a minimal example that demonstrates the core concepts:

```rust
use botcore::engine::Engine;
use botcore::types::{Collector, Strategy, Executor};
use botcore::Result;

// 1. Define your event and action types
#[derive(Debug, Clone)]
struct MyEvent {
    data: String,
}

#[derive(Debug, Clone)]
struct MyAction {
    command: String,
}

// 2. Implement a collector to source events
#[async_trait]
impl Collector<MyEvent> for MyCollector {
    async fn get_event_stream(&self) -> Result<CollectorStream<'_, MyEvent>> {
        // Return a stream of events
    }
}

// 3. Implement a strategy to process events
#[async_trait]
impl Strategy<MyEvent, MyAction> for MyStrategy {
    async fn sync_state(&mut self) -> Result<()> {
        // Load initial state if needed
        Ok(())
    }

    async fn process_event(&mut self, event: MyEvent) -> Vec<MyAction> {
        // Process event and return actions
    }
}

// 4. Implement an executor to handle actions
#[async_trait]
impl Executor<MyAction> for MyExecutor {
    async fn execute(&self, action: MyAction) -> Result<()> {
        // Execute the action
        Ok(())
    }
}

// 5. Create and run the engine
#[tokio::main]
async fn main() -> Result<()> {
    let mut engine = Engine::new()
        .with_event_channel_capacity(1024)
        .with_action_channel_capacity(1024);

    engine.add_collector(Box::new(MyCollector));
    engine.add_strategy(Box::new(MyStrategy));
    engine.add_executor(Box::new(MyExecutor));

    let join_set = engine.run().await?;
    join_set.await;
    Ok(())
}
```

## Architecture

The framework is built around three main traits:

### Collector

A source of events that your bot will process. Examples include:

- Blockchain event listeners
- WebSocket API clients
- Database change streams
- File system watchers

### Strategy

The core logic of your bot that processes events and decides what actions to take.
Strategies can:

- Maintain state between events
- Apply complex decision logic
- Generate multiple actions per event
- Filter out irrelevant events

### Executor

Responsible for carrying out actions generated by strategies. Examples include:

- Transaction submitters
- API clients
- Database writers
- Notification senders

## Examples

Check out the `examples/` directory for complete working examples:

- `block_trader.rs`: A simple bot that executes trades based on block events
  ```sh
  # Run the block trader example
  cargo run --example block_trader
  ```
- More examples coming soon!

To run any example, use the `cargo run --example` command followed by the example name (without the `.rs` extension).

## Metrics

The engine automatically collects Prometheus metrics for:

- Event processing latency
- Action execution latency
- Queue sizes
- Error counts
- Total events processed
- Total actions executed

These metrics can be exposed via a Prometheus endpoint in your application.

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

## License

This project is licensed under the MIT License - see the LICENSE file for details.
